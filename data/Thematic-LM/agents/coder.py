"""Coder Agent for generating semantic codes from explanations."""

import json
import logging
import re
from dataclasses import dataclass
from typing import List, Optional, Dict, Any

from providers.base import LLMProvider

logger = logging.getLogger(__name__)


@dataclass
class Code:
    """A single code generated by the Coder Agent."""

    code_text: str
    quote: str
    quote_id: str = ""
    confidence: float = 1.0


# Base system prompt (no identity)
CODER_SYSTEM_PROMPT_BASE = """You are a coder in the thematic analysis of SAE (Sparse Autoencoder) feature explanations.

When given a feature explanation, write 1-3 codes for the explanation. The code should capture concepts or ideas with the most analytical interest. For each code, extract a quote from the explanation corresponding to the code. The quote needs to be an exact extract from the text.

Guidelines:
1. Generate 1-3 codes per explanation
2. Each code should be 2-5 words, lowercase, as a descriptive noun phrase
3. Codes should be specific and descriptive (avoid generic terms like "tokens", "words", "text")
4. Focus on the distinctive semantic aspect - what makes this feature unique
5. The quote must be an exact substring from the input text

Good code examples:
- "temporal expressions"
- "negative sentiment markers"
- "scientific terminology"
- "question formation patterns"
- "possessive pronouns"

Bad code examples (too generic):
- "words"
- "language patterns"
- "text features"

Output the codes and quotes in the following JSON format:
{
  "codes": [
    {"code": "temporal expressions", "quote": "words related to time and duration"},
    {"code": "date formatting", "quote": "patterns like dates and timestamps"}
  ]
}

Always output valid JSON."""


# Identity prompt template (following Thematic-LM paper exactly)
# Paper: "agents are instructed to interpret the data through the lens of their assigned
# identities, reflecting on how someone with such a background might perceive and analyse
# the information"
IDENTITY_PROMPT_TEMPLATE = """
You are instructed to interpret the data through the lens of {identity_description}.

Reflect on how someone with such a background might perceive and analyse the information. Consider what aspects would be most analytically interesting from this perspective.

Your identity perspective: {identity_name}
"""


# Predefined coder identities for SAE feature analysis
CODER_IDENTITIES = {
    "linguist": {
        "name": "Linguistic Analyst",
        "description": "a computational linguist who focuses on grammatical structures, syntax patterns, morphological features, and linguistic phenomena in text"
    },
    "semanticist": {
        "name": "Semantic Analyst",
        "description": "a semantic analyst who focuses on meaning, conceptual relationships, word sense disambiguation, and how context shapes interpretation"
    },
    "pragmatist": {
        "name": "Pragmatic Analyst",
        "description": "a pragmatic analyst who focuses on language use in context, discourse functions, speaker intent, and communicative purposes"
    },
    "domain_expert": {
        "name": "Domain Expert",
        "description": "a domain expert who focuses on specialized terminology, technical vocabulary, field-specific patterns, and expert knowledge markers"
    },
    "cognitive": {
        "name": "Cognitive Analyst",
        "description": "a cognitive scientist who focuses on how language reflects mental processes, attention patterns, reasoning structures, and cognitive load"
    }
}


class CoderAgent:
    """Agent for generating semantic codes from SAE feature explanations.

    The Coder Agent analyzes explanation text and produces 1-3 semantic codes
    that capture the core meaning. Each code includes a supporting quote from
    the original text as evidence.

    Following Thematic-LM, coders can be assigned different identity perspectives
    to encourage diverse interpretations of the same data.
    """

    def __init__(
        self,
        llm: LLMProvider,
        coder_id: str = "coder_default",
        identity: Optional[str] = None,
        custom_identity: Optional[Dict[str, str]] = None,
        max_codes: int = 3
    ):
        """Initialize the Coder Agent.

        Args:
            llm: LLM provider for generating codes
            coder_id: Unique identifier for this coder
            identity: Predefined identity key (e.g., "linguist", "semanticist")
            custom_identity: Custom identity dict with 'name' and 'description'
            max_codes: Maximum number of codes per explanation (default: 3)
        """
        self.llm = llm
        self.coder_id = coder_id
        self.max_codes = max_codes

        # Build system prompt with identity if provided
        self.system_prompt = CODER_SYSTEM_PROMPT_BASE

        if custom_identity:
            self.identity_name = custom_identity.get("name", "Custom Analyst")
            identity_prompt = IDENTITY_PROMPT_TEMPLATE.format(
                identity_name=self.identity_name,
                identity_description=custom_identity.get("description", "an analyst")
            )
            self.system_prompt = identity_prompt + "\n" + CODER_SYSTEM_PROMPT_BASE
        elif identity and identity in CODER_IDENTITIES:
            identity_config = CODER_IDENTITIES[identity]
            self.identity_name = identity_config["name"]
            identity_prompt = IDENTITY_PROMPT_TEMPLATE.format(
                identity_name=self.identity_name,
                identity_description=identity_config["description"]
            )
            self.system_prompt = identity_prompt + "\n" + CODER_SYSTEM_PROMPT_BASE
        else:
            self.identity_name = None

    def code(
        self,
        explanation_text: str,
        quote_id: str = "",
        existing_codes: Optional[List[str]] = None
    ) -> List[Code]:
        """Generate codes for a single explanation.

        Args:
            explanation_text: The SAE feature explanation to code
            quote_id: Identifier for the explanation (e.g., "feature_123_llama")
            existing_codes: Optional list of existing code labels for consistency

        Returns:
            List of Code objects (1-3 codes)
        """
        prompt = f'Analyze this SAE feature explanation and generate semantic codes:\n\n"{explanation_text}"'

        if existing_codes:
            codes_str = ", ".join(f'"{c}"' for c in existing_codes[:15])
            prompt += f"\n\nExisting codes in codebook (use similar phrasing if applicable):\n{codes_str}"

        try:
            response = self.llm.generate_json(prompt, system=self.system_prompt)
            return self._parse_response(response, explanation_text, quote_id)
        except Exception as e:
            logger.warning(f"LLM generation failed for coder {self.coder_id}: {e}")
            return self._fallback_code(explanation_text, quote_id)

    def code_batch(
        self,
        explanations: List[Dict[str, Any]],
        existing_codes: Optional[List[str]] = None
    ) -> List[Dict[str, Any]]:
        """Generate codes for a batch of explanations.

        Args:
            explanations: List of dicts with 'text' and 'quote_id' keys
            existing_codes: Optional list of existing code labels

        Returns:
            List of dicts with 'quote_id' and 'codes' keys
        """
        results = []
        for exp in explanations:
            codes = self.code(
                explanation_text=exp["text"],
                quote_id=exp.get("quote_id", ""),
                existing_codes=existing_codes
            )
            results.append({
                "quote_id": exp.get("quote_id", ""),
                "codes": [
                    {"code": c.code_text, "quote": c.quote, "quote_id": c.quote_id}
                    for c in codes
                ]
            })
        return results

    def _parse_response(self, response: str, explanation_text: str, quote_id: str) -> List[Code]:
        """Parse LLM response into Code objects."""
        try:
            data = json.loads(response)
            codes = []

            for item in data.get("codes", []):
                code_text = item.get("code", "").strip().lower()
                quote = item.get("quote", "").strip()

                if not code_text:
                    continue

                # Validate quote is in original text (case-insensitive)
                if quote and quote.lower() in explanation_text.lower():
                    codes.append(Code(
                        code_text=code_text,
                        quote=quote,
                        quote_id=quote_id,
                        confidence=1.0
                    ))
                elif code_text:
                    # Use first part of explanation as fallback quote
                    fallback_quote = explanation_text[:100].strip()
                    if len(explanation_text) > 100:
                        fallback_quote += "..."
                    codes.append(Code(
                        code_text=code_text,
                        quote=fallback_quote,
                        quote_id=quote_id,
                        confidence=0.8
                    ))

            return codes[:self.max_codes]

        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse JSON response: {e}")
            return self._extract_codes_fallback(response, explanation_text, quote_id)

    def _extract_codes_fallback(self, response: str, explanation_text: str, quote_id: str) -> List[Code]:
        """Extract codes from malformed JSON response."""
        codes = []
        code_pattern = r'"code"\s*:\s*"([^"]+)"'
        matches = re.findall(code_pattern, response)

        for match in matches[:self.max_codes]:
            code_text = match.strip().lower()
            if code_text:
                fallback_quote = explanation_text[:100].strip()
                codes.append(Code(
                    code_text=code_text,
                    quote=fallback_quote,
                    quote_id=quote_id,
                    confidence=0.6
                ))

        if codes:
            return codes

        return self._fallback_code(explanation_text, quote_id)

    def _fallback_code(self, explanation_text: str, quote_id: str) -> List[Code]:
        """Generate a simple fallback code when LLM fails."""
        words = explanation_text.lower().split()[:5]
        fallback_text = " ".join(words)

        return [Code(
            code_text=f"uncoded: {fallback_text}",
            quote=explanation_text[:100],
            quote_id=quote_id,
            confidence=0.3
        )]

    def get_identity_info(self) -> Optional[Dict[str, str]]:
        """Get information about this coder's identity."""
        if self.identity_name:
            return {
                "coder_id": self.coder_id,
                "identity_name": self.identity_name
            }
        return None
